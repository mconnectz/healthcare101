"use strict";
const moment = require("moment");
const mongoose_1 = require("mongoose");
const mongooseBetterId = (schema, { connection, field = '_id', prefix = '', suffix = {}, timestamp = {}, modelName = '_id_counter', } = {}) => {
    if (!connection) {
        throw new Error('connection is required!');
    }
    const mixedSuffix = Object.assign({
        start: 0,
        step: 1,
        max: 999,
    }, suffix);
    if (mixedSuffix.start >= mixedSuffix.max) {
        throw new Error('suffix.max should greater than suffix.start');
    }
    if (mixedSuffix.step > (mixedSuffix.max - mixedSuffix.start)) {
        throw new Error('suffix.step should not greater than difference between suffix.start and suffix.max');
    }
    const mixedTimestamp = Object.assign({
        enable: true,
        format: 'YYMMDDHHmm',
    }, timestamp);
    let IdCounterModel;
    let counterSchema;
    try {
        IdCounterModel = connection.model(modelName);
    }
    catch (err) {
        if (err.name === 'MissingSchemaError') {
            counterSchema = new mongoose_1.Schema({
                srcModel: { type: String, required: true },
                field: { type: String, required: true },
                count: { type: Number, default: mixedSuffix.start, min: mixedSuffix.start, max: mixedSuffix.max },
            });
            counterSchema.index({ field: 1, srcModel: 1 }, { unique: true });
            counterSchema.methods.fetch = async function () {
                return await this.constructor.findOneAndUpdate({
                    srcModel: this.srcModel,
                    field: this.field,
                }, {}, {
                    upsert: true,
                    new: true,
                    setDefaultsOnInsert: true,
                });
            };
            counterSchema.methods.resetCount = async function () {
                const counter = await this.fetch();
                if (counter.count <= mixedSuffix.max) {
                    return await counter.nextCount();
                }
                else {
                    const nextCounter = await this.constructor.findOneAndUpdate({
                        model: this.model,
                        field: this.field,
                        count: { $gt: mixedSuffix.max },
                    }, {
                        $set: {
                            count: mixedSuffix.start,
                        },
                    }, { new: true });
                    if (!nextCounter) {
                        return await this.nextCount();
                    }
                    else {
                        return nextCounter.count;
                    }
                }
            };
            counterSchema.methods.nextCount = async function () {
                let counter = await this.fetch();
                counter = await this.constructor.findByIdAndUpdate(counter._id, {
                    $inc: {
                        count: mixedSuffix.step,
                    },
                }, { new: true });
                if (counter.count > mixedSuffix.max) {
                    return await counter.resetCount();
                }
                else {
                    return counter.count;
                }
            };
            IdCounterModel = connection.model(modelName, counterSchema);
        }
        else {
            throw err;
        }
    }
    const suffixLength = mixedSuffix.max.toString().length;
    const pad = (count) => `${new Array(suffixLength).fill('0').join('')}${count}`.slice(-suffixLength);
    const fields = {};
    fields[field] = { type: String, required: true };
    if (field !== '_id') {
        fields[field].unique = true;
    }
    schema.add(fields);
    schema.pre('validate', function (next) {
        if (this.isNew && !this[field]) {
            new IdCounterModel({
                srcModel: this.constructor.modelName,
                field,
            }).nextCount().then(count => {
                this[field] = `${prefix}${mixedTimestamp.enable ? moment().format(mixedTimestamp.format) : ''}${pad(count)}`;
                next();
            }).catch(next);
        }
        else {
            next();
        }
    });
    schema.statics.genId = function (cb = (err, id) => null) {
        return new Promise((resolve, reject) => {
            new IdCounterModel({
                srcModel: this.modelName,
                field,
            }).nextCount().then(count => {
                const id = `${prefix}${mixedTimestamp.enable ? moment().format(mixedTimestamp.format) : ''}${pad(count)}`;
                cb(null, id);
                resolve(id);
            }).catch(err => {
                cb(err);
                reject(err);
            });
        });
    };
};
module.exports = mongooseBetterId;
//# sourceMappingURL=index.js.map